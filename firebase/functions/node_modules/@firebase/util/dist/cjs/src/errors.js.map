{"version":3,"sources":["../src/errors.ts"],"names":[],"mappings":"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","file":"errors.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // Typescript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if (e.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nexport type ErrorList<T> = { [code: string]: string };\n\nconst ERROR_NAME = 'FirebaseError';\n\nexport interface StringLike {\n  toString: () => string;\n}\n\nlet captureStackTrace: (obj: Object, fn?: Function) => void = (Error as any)\n  .captureStackTrace;\n\n// Export for faking in tests\nexport function patchCapture(captureFake?: any): any {\n  let result: any = captureStackTrace;\n  captureStackTrace = captureFake;\n  return result;\n}\n\nexport interface FirebaseError {\n  // Unique code for error - format is service/error-code-string\n  code: string;\n\n  // Developer-friendly error message.\n  message: string;\n\n  // Always 'FirebaseError'\n  name: string;\n\n  // Where available - stack backtrace in a string\n  stack: string;\n}\n\nexport class FirebaseError implements FirebaseError {\n  public stack: string;\n  public name: string;\n\n  constructor(public code: string, public message: string) {\n    let stack: string;\n    // We want the stack value, if implemented by Error\n    if (captureStackTrace) {\n      // Patches this.stack, omitted calls above ErrorFactory#create\n      captureStackTrace(this, ErrorFactory.prototype.create);\n    } else {\n      let err = Error.apply(this, arguments);\n      this.name = ERROR_NAME;\n      // Make non-enumerable getter for the property.\n      Object.defineProperty(this, 'stack', {\n        get: function() {\n          return err.stack;\n        }\n      });\n    }\n  }\n}\n\n// Back-door inheritance\nFirebaseError.prototype = Object.create(Error.prototype) as FirebaseError;\nFirebaseError.prototype.constructor = FirebaseError;\n(FirebaseError.prototype as any).name = ERROR_NAME;\n\nexport class ErrorFactory<T extends string> {\n  // Matches {$name}, by default.\n  public pattern = /\\{\\$([^}]+)}/g;\n\n  constructor(\n    private service: string,\n    private serviceName: string,\n    private errors: ErrorList<T>\n  ) {\n    // empty\n  }\n\n  create(code: T, data?: { [prop: string]: StringLike }): FirebaseError {\n    if (data === undefined) {\n      data = {};\n    }\n\n    let template = this.errors[code as string];\n\n    let fullCode = this.service + '/' + code;\n    let message: string;\n\n    if (template === undefined) {\n      message = 'Error';\n    } else {\n      message = template.replace(this.pattern, (match, key) => {\n        let value = data![key];\n        return value !== undefined ? value.toString() : '<' + key + '?>';\n      });\n    }\n\n    // Service: Error message (service/code).\n    message = this.serviceName + ': ' + message + ' (' + fullCode + ').';\n    let err = new FirebaseError(fullCode, message);\n\n    // Populate the Error object with message parts for programmatic\n    // accesses (e.g., e.file).\n    for (let prop in data) {\n      if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {\n        continue;\n      }\n      (err as any)[prop] = data[prop];\n    }\n\n    return err;\n  }\n}\n"]}