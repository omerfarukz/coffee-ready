{"version":3,"sources":["../src/subscribe.ts"],"names":[],"mappings":"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","file":"subscribe.js","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type NextFn<T> = (value: T) => void;\nexport type ErrorFn = (error: Error) => void;\nexport type CompleteFn = () => void;\n\nexport interface Observer<V, E> {\n  // Called once for each value in a stream of values.\n  next(value: V | null): any;\n\n  // A stream terminates by a single call to EITHER error() or complete().\n  error(error: E): any;\n\n  // No events will be sent to next() once complete() is called.\n  complete(): any;\n}\n\n// Allow for any of the Observer methods to be undefined.\nexport interface PartialObserver<T> {\n  next?: NextFn<T>;\n  error?: ErrorFn;\n  complete?: CompleteFn;\n}\n\n// TODO: Support also Unsubscribe.unsubscribe?\nexport type Unsubscribe = () => void;\n\n/**\n * The Subscribe interface has two forms - passing the inline function\n * callbacks, or a object interface with callback properties.\n */\nexport interface Subscribe<T> {\n  (next?: NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;\n  (observer: PartialObserver<T>): Unsubscribe;\n}\n\nexport interface Observable<T> {\n  // Subscribe method\n  subscribe: Subscribe<T>;\n}\n\nexport type Executor<T> = (observer: Observer<T, Error>) => void;\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nexport function createSubscribe<T>(\n  executor: Executor<T>,\n  onNoObservers?: Executor<T>\n): Subscribe<T> {\n  let proxy = new ObserverProxy<T>(executor, onNoObservers);\n  return proxy.subscribe.bind(proxy);\n}\n\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy<T> implements Observer<T, Error> {\n  private observers: Array<Observer<T, Error>> | undefined = [];\n  private unsubscribes: Unsubscribe[] = [];\n  private onNoObservers: Executor<T> | undefined;\n  private observerCount = 0;\n  // Micro-task scheduling by calling task.then().\n  private task = Promise.resolve();\n  private finalized = false;\n  private finalError: Error;\n\n  /**\n   * @param executor Function which can make calls to a single Observer\n   *     as a proxy.\n   * @param onNoObservers Callback when count of Observers goes to zero.\n   */\n  constructor(executor: Executor<T>, onNoObservers?: Executor<T>) {\n    this.onNoObservers = onNoObservers;\n    // Call the executor asynchronously so subscribers that are called\n    // synchronously after the creation of the subscribe function\n    // can still receive the very first value generated in the executor.\n    this.task\n      .then(() => {\n        executor(this);\n      })\n      .catch(e => {\n        this.error(e);\n      });\n  }\n\n  next(value: T) {\n    this.forEachObserver((observer: Observer<T, Error>) => {\n      observer.next(value);\n    });\n  }\n\n  error(error: Error) {\n    this.forEachObserver((observer: Observer<T, Error>) => {\n      observer.error(error);\n    });\n    this.close(error);\n  }\n\n  complete() {\n    this.forEachObserver((observer: Observer<T, Error>) => {\n      observer.complete();\n    });\n    this.close();\n  }\n\n  /**\n   * Subscribe function that can be used to add an Observer to the fan-out list.\n   *\n   * - We require that no event is sent to a subscriber sychronously to their\n   *   call to subscribe().\n   */\n  subscribe(\n    nextOrObserver: PartialObserver<T> | Function,\n    error?: ErrorFn,\n    complete?: CompleteFn\n  ): Unsubscribe {\n    let observer: Observer<T, Error>;\n\n    if (\n      nextOrObserver === undefined &&\n      error === undefined &&\n      complete === undefined\n    ) {\n      throw new Error('Missing Observer.');\n    }\n\n    // Assemble an Observer object when passed as callback functions.\n    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n      observer = nextOrObserver as Observer<T, Error>;\n    } else {\n      observer = {\n        next: (nextOrObserver as any) as NextFn<T>,\n        error: error,\n        complete: complete\n      } as Observer<T, Error>;\n    }\n\n    if (observer.next === undefined) {\n      observer.next = noop as NextFn<T>;\n    }\n    if (observer.error === undefined) {\n      observer.error = noop as ErrorFn;\n    }\n    if (observer.complete === undefined) {\n      observer.complete = noop as CompleteFn;\n    }\n\n    let unsub = this.unsubscribeOne.bind(this, this.observers!.length);\n\n    // Attempt to subscribe to a terminated Observable - we\n    // just respond to the Observer with the final error or complete\n    // event.\n    if (this.finalized) {\n      this.task.then(() => {\n        try {\n          if (this.finalError) {\n            observer.error(this.finalError);\n          } else {\n            observer.complete();\n          }\n        } catch (e) {\n          // nothing\n        }\n        return;\n      });\n    }\n\n    this.observers!.push(observer as Observer<T, Error>);\n\n    return unsub;\n  }\n\n  // Unsubscribe is synchronous - we guarantee that no events are sent to\n  // any unsubscribed Observer.\n  private unsubscribeOne(i: number) {\n    if (this.observers === undefined || this.observers[i] === undefined) {\n      return;\n    }\n\n    delete this.observers[i];\n\n    this.observerCount -= 1;\n    if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n      this.onNoObservers(this);\n    }\n  }\n\n  private forEachObserver(fn: (observer: Observer<T, Error>) => void): void {\n    if (this.finalized) {\n      // Already closed by previous event....just eat the additional values.\n      return;\n    }\n\n    // Since sendOne calls asynchronously - there is no chance that\n    // this.observers will become undefined.\n    for (let i = 0; i < this.observers!.length; i++) {\n      this.sendOne(i, fn);\n    }\n  }\n\n  // Call the Observer via one of it's callback function. We are careful to\n  // confirm that the observe has not been unsubscribed since this asynchronous\n  // function had been queued.\n  private sendOne(i: number, fn: (observer: Observer<T, Error>) => void): void {\n    // Execute the callback asynchronously\n    this.task.then(() => {\n      if (this.observers !== undefined && this.observers[i] !== undefined) {\n        try {\n          fn(this.observers[i]);\n        } catch (e) {\n          // Ignore exceptions raised in Observers or missing methods of an\n          // Observer.\n          // Log error to console. b/31404806\n          if (typeof console !== 'undefined' && console.error) {\n            console.error(e);\n          }\n        }\n      }\n    });\n  }\n\n  private close(err?: Error): void {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    if (err !== undefined) {\n      this.finalError = err;\n    }\n    // Proxy is no longer needed - garbage collect references\n    this.task.then(() => {\n      this.observers = undefined;\n      this.onNoObservers = undefined;\n    });\n  }\n}\n\n/** Turn synchronous function into one called asynchronously. */\nexport function async(fn: Function, onError?: ErrorFn): Function {\n  return (...args: any[]) => {\n    Promise.resolve(true)\n      .then(() => {\n        fn(...args);\n      })\n      .catch((error: Error) => {\n        if (onError) {\n          onError(error);\n        }\n      });\n  };\n}\n\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj: any, methods: string[]): boolean {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  for (let method of methods) {\n    if (method in obj && typeof obj[method] === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction noop(): void {\n  // do nothing\n}\n"]}